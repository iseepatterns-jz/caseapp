name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production
      force_cleanup:
        description: "Force cleanup of existing resources"
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: court-case-management
  DEPLOYMENT_TIMEOUT: 3600 # 60 minutes
  HEALTH_CHECK_TIMEOUT: 300 # 5 minutes

jobs:
  test:
    runs-on: ubuntu-latest
    timeout-minutes: 20 # Prevent hanging tests

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
          POSTGRES_INITDB_ARGS: "--auth-host=scram-sha-256 --auth-local=scram-sha-256"
        options: >-
          --health-cmd "pg_isready -U postgres -d test_db"
          --health-interval 3s
          --health-timeout 15s
          --health-retries 20
          --health-start-period 60s
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 3s
          --health-timeout 15s
          --health-retries 20
          --health-start-period 30s
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        timeout-minutes: 2

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"
        timeout-minutes: 3

      - name: Cache Python dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-
        timeout-minutes: 2

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r caseapp/requirements.txt
          pip install pytest pytest-asyncio pytest-cov
        timeout-minutes: 5

      - name: Wait for services to be ready
        run: |
          echo "ğŸ” Waiting for services to be ready with Docker exec commands..."

          # Function for exponential backoff retry with Docker exec
          retry_with_backoff() {
            local max_attempts=20
            local delay=3
            local attempt=1
            local command="$1"
            local service_name="$2"
            
            while [ $attempt -le $max_attempts ]; do
              echo "â³ Attempt $attempt/$max_attempts: Checking $service_name..."
              
              if eval "$command"; then
                echo "âœ… $service_name is ready!"
                return 0
              fi
              
              if [ $attempt -eq $max_attempts ]; then
                echo "âŒ $service_name failed to become ready after $max_attempts attempts"
                echo "ğŸ” Debugging $service_name status..."
                
                # Show Docker containers
                echo "Docker containers:"
                docker ps -a || true
                
                # Additional debugging for PostgreSQL
                if [ "$service_name" = "PostgreSQL" ]; then
                  echo "PostgreSQL container logs:"
                  POSTGRES_CONTAINER=$(docker ps -q --filter ancestor=postgres:15)
                  if [ -n "$POSTGRES_CONTAINER" ]; then
                    docker logs "$POSTGRES_CONTAINER" 2>/dev/null | tail -30 || true
                    echo "Testing PostgreSQL connection via Docker exec:"
                    docker exec "$POSTGRES_CONTAINER" pg_isready -U postgres -d test_db || true
                  else
                    echo "PostgreSQL container not found"
                  fi
                fi
                
                # Additional debugging for Redis
                if [ "$service_name" = "Redis" ]; then
                  echo "Redis container logs:"
                  REDIS_CONTAINER=$(docker ps -q --filter ancestor=redis:7-alpine)
                  if [ -n "$REDIS_CONTAINER" ]; then
                    docker logs "$REDIS_CONTAINER" 2>/dev/null | tail -30 || true
                    echo "Testing Redis connection via Docker exec:"
                    docker exec "$REDIS_CONTAINER" redis-cli ping || true
                  else
                    echo "Redis container not found"
                  fi
                fi
                
                return 1
              fi
              
              echo "â³ $service_name not ready, waiting ${delay}s before retry..."
              sleep $delay
              
              # Exponential backoff with max delay of 15 seconds
              if [ $delay -lt 15 ]; then
                delay=$((delay + 2))
              fi
              
              attempt=$((attempt + 1))
            done
          }

          # Wait for PostgreSQL with Docker exec
          echo "ğŸ˜ Waiting for PostgreSQL to be ready..."
          retry_with_backoff "docker exec \$(docker ps -q --filter ancestor=postgres:15) pg_isready -U postgres -d test_db > /dev/null 2>&1" "PostgreSQL"

          # Wait for Redis with Docker exec
          echo "ğŸ”´ Waiting for Redis to be ready..."
          retry_with_backoff "docker exec \$(docker ps -q --filter ancestor=redis:7-alpine) redis-cli ping > /dev/null 2>&1" "Redis"

          echo "ğŸ‰ All services are ready and healthy!"
        timeout-minutes: 6

      - name: Run backend tests
        working-directory: caseapp/backend
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
          REDIS_URL: redis://localhost:6379
          SECRET_KEY: test-secret-key-for-ci
          ENABLE_AI_FEATURES: false
        run: |
          python -m pytest tests/test_ci_basic.py -v --cov=. --cov-report=xml --cov-report=term-missing --tb=short
        timeout-minutes: 10

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: caseapp/backend/coverage.xml
          flags: backend
          name: backend-coverage
        timeout-minutes: 2
        continue-on-error: true # Don't fail build if coverage upload fails

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    timeout-minutes: 30 # Prevent hanging builds
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'

    outputs:
      backend-image: ${{ steps.meta.outputs.tags }}
      backend-digest: ${{ steps.build-backend.outputs.digest }}
      media-image: ${{ steps.meta-media.outputs.tags }}
      media-digest: ${{ steps.build-media.outputs.digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        timeout-minutes: 2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        timeout-minutes: 2

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
        timeout-minutes: 2

      - name: Verify Docker Hub credentials
        run: |
          if [ -z "${{ secrets.DOCKER_USERNAME }}" ] || [ -z "${{ secrets.DOCKER_PASSWORD }}" ]; then
            echo "âŒ Docker Hub credentials not configured"
            echo "Please add DOCKER_USERNAME and DOCKER_PASSWORD to repository secrets"
            exit 1
          fi
          echo "âœ… Docker Hub credentials verified"

      - name: Extract backend metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKER_USERNAME }}/court-case-backend
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Extract media processor metadata
        id: meta-media
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKER_USERNAME }}/court-case-media
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push backend image
        id: build-backend
        uses: docker/build-push-action@v5
        with:
          context: ./caseapp
          file: ./caseapp/Dockerfile
          target: backend-base
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
        timeout-minutes: 20

      - name: Build and push media processor image
        id: build-media
        uses: docker/build-push-action@v5
        with:
          context: ./caseapp
          file: ./caseapp/Dockerfile
          target: media-processor
          push: true
          tags: ${{ steps.meta-media.outputs.tags }}
          labels: ${{ steps.meta-media.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
        timeout-minutes: 15

      - name: Verify image accessibility with validation gates
        run: |
          echo "ğŸ” Running Docker image validation gates..."

          # Set environment variables for the validation script
          export DOCKER_USERNAME="${{ secrets.DOCKER_USERNAME }}"
          export AWS_REGION="${{ env.AWS_REGION }}"

          # Change to caseapp directory and run validation
          cd caseapp
          chmod +x scripts/deployment-validation-gates.sh

          # Run only Docker image validation (Gate 1)
          echo "Validating Docker image accessibility..."
          if docker manifest inspect ${{ secrets.DOCKER_USERNAME }}/court-case-backend:latest > /dev/null 2>&1; then
            echo "âœ… Backend image accessible: ${{ secrets.DOCKER_USERNAME }}/court-case-backend:latest"
          else
            echo "âŒ Backend image not accessible"
            exit 1
          fi

          if docker manifest inspect ${{ secrets.DOCKER_USERNAME }}/court-case-media:latest > /dev/null 2>&1; then
            echo "âœ… Media image accessible: ${{ secrets.DOCKER_USERNAME }}/court-case-media:latest"
          else
            echo "âŒ Media image not accessible"
            exit 1
          fi

          echo "ğŸ‰ All Docker images are accessible and ready for deployment"
        timeout-minutes: 2

  security-scan:
    needs: build-and-push
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    continue-on-error: true # Don't fail deployment if security scan fails

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        timeout-minutes: 2

      - name: Run Trivy vulnerability scanner on backend
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ secrets.DOCKER_USERNAME }}/court-case-backend:latest
          format: "sarif"
          output: "trivy-backend-results.sarif"
        timeout-minutes: 10
        continue-on-error: true

      - name: Run Trivy vulnerability scanner on media processor
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ secrets.DOCKER_USERNAME }}/court-case-media:latest
          format: "sarif"
          output: "trivy-media-results.sarif"
        timeout-minutes: 10
        continue-on-error: true

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-backend-results.sarif"
        continue-on-error: true
        timeout-minutes: 2

      - name: Upload Media Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-media-results.sarif"
        continue-on-error: true
        timeout-minutes: 2

      - name: Security scan summary
        run: |
          echo "ğŸ”’ Security scan completed for both backend and media processor images"
          echo "ğŸ“Š Check the Security tab for detailed vulnerability reports"
          echo "â„¹ï¸  Note: Security scan failures do not block deployment in this configuration"

  deploy-staging:
    needs: [test, build-and-push]
    runs-on: ubuntu-latest
    timeout-minutes: 45 # Extended timeout for deployment
    if: github.ref == 'refs/heads/develop' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        timeout-minutes: 2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
        timeout-minutes: 1

      - name: Verify AWS credentials and permissions
        run: |
          echo "ğŸ” Verifying AWS credentials..."
          aws sts get-caller-identity

          echo "ğŸ” Checking required AWS permissions..."
          # Test basic permissions
          aws cloudformation list-stacks --region ${{ env.AWS_REGION }} --max-items 1 > /dev/null
          aws ecs list-clusters --region ${{ env.AWS_REGION }} --max-items 1 > /dev/null
          aws rds describe-db-instances --region ${{ env.AWS_REGION }} --max-items 1 > /dev/null

          echo "âœ… AWS credentials and permissions verified"
        timeout-minutes: 2

      - name: Set up Python for CDK
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"
        timeout-minutes: 3

      - name: Install Node.js for CDK CLI
        uses: actions/setup-node@v4
        with:
          node-version: "20"
        timeout-minutes: 2

      - name: Install AWS CDK CLI
        run: npm install -g aws-cdk
        timeout-minutes: 3

      - name: Run enhanced pre-deployment validation with auto-resolution
        working-directory: caseapp
        run: |
          echo "ğŸ” Running enhanced pre-deployment validation with automatic conflict resolution..."

          # Make scripts executable
          chmod +x scripts/enhanced-deployment-validation.sh
          chmod +x scripts/resolve-rds-deletion-protection.sh
          chmod +x scripts/cleanup-cloudformation-stack.sh

          # Set environment variables for enhanced validation
          export AUTO_RESOLVE=true
          export CI=true
          export GITHUB_ACTIONS=true

          # Run enhanced validation with automatic resolution
          if ./scripts/enhanced-deployment-validation.sh; then
            echo "âœ… All deployment validation checks passed"
          else
            exit_code=$?
            if [ $exit_code -eq 1 ]; then
              echo "âš ï¸  Deployment validation completed with warnings after auto-resolution"
              echo "ğŸš€ Proceeding with deployment..."
            else
              echo "âŒ Enhanced deployment validation failed even after auto-resolution"
              
              # Fallback to manual cleanup if force cleanup is requested
              if [ "${{ github.event.inputs.force_cleanup }}" = "true" ]; then
                echo "ğŸ§¹ Force cleanup requested as fallback, running manual cleanup..."
                echo "y" | ./scripts/cleanup-cloudformation-stack.sh || true
                
                echo "ğŸ” Re-running basic validation after manual cleanup..."
                chmod +x scripts/deployment-validation-gates.sh
                ./scripts/deployment-validation-gates.sh
              else
                echo "âŒ Enhanced validation failed and force cleanup not requested"
                echo "Re-run workflow with force_cleanup=true to attempt manual cleanup"
                exit 1
              fi
            fi
          fi
        timeout-minutes: 25

      - name: Deploy to staging with validation and retry
        working-directory: caseapp
        env:
          ENVIRONMENT: staging
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          STACK_NAME: CourtCaseManagementStack-Staging
        run: |
          echo "ğŸš€ Starting staging deployment with enhanced reliability..."

          # Make scripts executable
          chmod +x scripts/deploy-with-validation.sh

          # Set stack name for staging
          export STACK_NAME="CourtCaseManagementStack-Staging"

          # Run deployment with validation and retry logic
          ./scripts/deploy-with-validation.sh
        timeout-minutes: 30

      - name: Run post-deployment validation
        working-directory: caseapp
        run: |
          echo "ğŸ” Running post-deployment validation..."

          # Wait for services to stabilize
          echo "â³ Waiting for services to stabilize..."
          sleep 120

          # Get stack outputs
          STACK_NAME="CourtCaseManagementStack-Staging"

          # Check if stack exists and get outputs
          if aws cloudformation describe-stacks --stack-name "$STACK_NAME" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
            echo "ğŸ“Š Stack outputs:"
            aws cloudformation describe-stacks \
              --stack-name "$STACK_NAME" \
              --region ${{ env.AWS_REGION }} \
              --query 'Stacks[0].Outputs' \
              --output table
            
            # Get load balancer DNS if available
            ALB_DNS=$(aws cloudformation describe-stacks \
              --stack-name "$STACK_NAME" \
              --region ${{ env.AWS_REGION }} \
              --query 'Stacks[0].Outputs[?OutputKey==`LoadBalancerDNS`].OutputValue' \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$ALB_DNS" ] && [ "$ALB_DNS" != "None" ]; then
              echo "ğŸŒ Load Balancer DNS: $ALB_DNS"
              
              # Health check with retry
              echo "ğŸ¥ Testing health endpoint..."
              for i in {1..5}; do
                if curl -f --connect-timeout 10 --max-time 30 "http://$ALB_DNS/health" > /dev/null 2>&1; then
                  echo "âœ… Health check passed on attempt $i"
                  break
                elif [ $i -eq 5 ]; then
                  echo "âš ï¸  Health check failed after 5 attempts, but continuing..."
                else
                  echo "â³ Health check attempt $i failed, retrying in 30s..."
                  sleep 30
                fi
              done
            else
              echo "âš ï¸  Load Balancer DNS not found in stack outputs"
            fi
          else
            echo "âš ï¸  Stack not found or not accessible"
          fi

          echo "âœ… Post-deployment validation completed"
        timeout-minutes: 10

      - name: Deployment status summary
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "ğŸ‰ Staging deployment completed successfully!"
            echo "ğŸ“ Environment: staging"
            echo "ğŸ·ï¸  Images deployed:"
            echo "   - Backend: ${{ secrets.DOCKER_USERNAME }}/court-case-backend:latest"
            echo "   - Media: ${{ secrets.DOCKER_USERNAME }}/court-case-media:latest"
          else
            echo "âŒ Staging deployment failed!"
            echo "ğŸ” Check the logs above for detailed error information"
            echo "ğŸ’¡ Consider running with force_cleanup=true if there are resource conflicts"
          fi

  deploy-production:
    needs: [test, build-and-push, security-scan]
    runs-on: ubuntu-latest
    timeout-minutes: 60 # Extended timeout for production deployment
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        timeout-minutes: 2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
        timeout-minutes: 1

      - name: Verify AWS credentials and permissions
        run: |
          echo "ğŸ” Verifying AWS credentials for production deployment..."

          # Verify credentials
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          USER_ARN=$(aws sts get-caller-identity --query Arn --output text)

          echo "ğŸ“‹ AWS Account ID: $ACCOUNT_ID"
          echo "ğŸ‘¤ User/Role ARN: $USER_ARN"

          # Verify required secrets
          if [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ] || [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
            echo "âŒ AWS credentials not configured in GitHub Secrets"
            echo "Please add AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY to repository secrets"
            exit 1
          fi

          if [ -z "${{ secrets.DOCKER_USERNAME }}" ] || [ -z "${{ secrets.DOCKER_PASSWORD }}" ]; then
            echo "âŒ Docker Hub credentials not configured in GitHub Secrets"
            echo "Please add DOCKER_USERNAME and DOCKER_PASSWORD to repository secrets"
            exit 1
          fi

          echo "ğŸ” Testing AWS service permissions..."
          # Test required AWS service permissions
          aws cloudformation list-stacks --region ${{ env.AWS_REGION }} --max-items 1 > /dev/null
          aws ecs list-clusters --region ${{ env.AWS_REGION }} --max-items 1 > /dev/null
          aws rds describe-db-instances --region ${{ env.AWS_REGION }} --max-items 1 > /dev/null
          aws ec2 describe-vpcs --region ${{ env.AWS_REGION }} --max-items 1 > /dev/null

          echo "âœ… AWS credentials and permissions verified for production"
        timeout-minutes: 3

      - name: Set up Python for CDK
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"
        timeout-minutes: 3

      - name: Install Node.js for CDK CLI
        uses: actions/setup-node@v4
        with:
          node-version: "20"
        timeout-minutes: 2

      - name: Install AWS CDK CLI
        run: npm install -g aws-cdk
        timeout-minutes: 3

      - name: Run comprehensive pre-deployment validation with auto-resolution
        working-directory: caseapp
        run: |
          echo "ğŸ” Running comprehensive pre-deployment validation with automatic conflict resolution for production..."

          # Make scripts executable
          chmod +x scripts/enhanced-deployment-validation.sh
          chmod +x scripts/resolve-rds-deletion-protection.sh
          chmod +x scripts/cleanup-cloudformation-stack.sh
          chmod +x scripts/analyze-resource-dependencies.sh

          # Set environment variables for enhanced validation
          export AUTO_RESOLVE=true
          export CI=true
          export GITHUB_ACTIONS=true

          # Run enhanced validation with automatic resolution
          if ./scripts/enhanced-deployment-validation.sh; then
            echo "âœ… All deployment validation checks passed"
          else
            exit_code=$?
            if [ $exit_code -eq 1 ]; then
              echo "âš ï¸  Deployment validation completed with warnings after auto-resolution"
              echo "ğŸš€ Proceeding with production deployment..."
            else
              echo "âŒ Enhanced deployment validation failed"
              
              # Run dependency analysis for detailed information
              echo "ğŸ” Running dependency analysis for additional details..."
              ./scripts/analyze-resource-dependencies.sh || true
              
              # Check if force cleanup is requested
              if [ "${{ github.event.inputs.force_cleanup }}" = "true" ]; then
                echo "ğŸ§¹ Force cleanup requested for production deployment..."
                echo "âš ï¸  This will delete existing resources including databases!"
                
                echo "y" | ./scripts/cleanup-cloudformation-stack.sh || true
                
                # Re-run enhanced validation after cleanup
                echo "ğŸ” Re-running enhanced validation after cleanup..."
                ./scripts/enhanced-deployment-validation.sh
              else
                echo "âŒ Production validation failed and force cleanup not requested"
                echo "This is a safety measure to prevent accidental data loss in production"
                echo "If you're certain you want to proceed, re-run with force_cleanup=true"
                exit 1
              fi
            fi
          fi
        timeout-minutes: 35

      - name: Deploy to production with enhanced reliability
        working-directory: caseapp
        env:
          ENVIRONMENT: production
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
        run: |
          echo "ğŸš€ Starting production deployment with enhanced reliability..."
          echo "âš ï¸  Production deployment - proceeding with caution"

          # Make deployment script executable
          chmod +x scripts/deploy-with-validation.sh

          # Run deployment with validation and retry logic
          ./scripts/deploy-with-validation.sh

          echo "âœ… Production deployment completed successfully"
        timeout-minutes: 60

      - name: Run comprehensive post-deployment validation
        run: |
          echo "ğŸ” Running comprehensive post-deployment validation..."

          # Extended wait for production services to stabilize
          echo "â³ Waiting for production services to fully stabilize..."
          sleep 180  # 3 minutes for production

          # Get stack outputs
          STACK_NAME="CourtCaseManagementStack"

          echo "ğŸ“Š Production stack outputs:"
          aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs' \
            --output table

          # Get load balancer DNS
          ALB_DNS=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`LoadBalancerDNS`].OutputValue' \
            --output text 2>/dev/null || echo "")

          if [ -n "$ALB_DNS" ] && [ "$ALB_DNS" != "None" ]; then
            echo "ğŸŒ Production Load Balancer DNS: $ALB_DNS"
            
            # Comprehensive health checks with retry
            echo "ğŸ¥ Running comprehensive health checks..."
            
            # Basic health check
            for i in {1..10}; do
              if curl -f --connect-timeout 10 --max-time 30 "http://$ALB_DNS/health" > /dev/null 2>&1; then
                echo "âœ… Basic health check passed on attempt $i"
                break
              elif [ $i -eq 10 ]; then
                echo "âŒ Basic health check failed after 10 attempts"
                exit 1
              else
                echo "â³ Health check attempt $i failed, retrying in 30s..."
                sleep 30
              fi
            done
            
            # API documentation check
            echo "ğŸ“š Testing API documentation endpoint..."
            if curl -f --connect-timeout 10 --max-time 30 "http://$ALB_DNS/docs" > /dev/null 2>&1; then
              echo "âœ… API documentation endpoint accessible"
            else
              echo "âš ï¸  API documentation endpoint not accessible (non-critical)"
            fi
            
            # Ready endpoint check
            echo "ğŸ¯ Testing readiness endpoint..."
            if curl -f --connect-timeout 10 --max-time 30 "http://$ALB_DNS/health/ready" > /dev/null 2>&1; then
              echo "âœ… Readiness endpoint accessible"
            else
              echo "âš ï¸  Readiness endpoint not accessible"
            fi
            
            echo "ğŸ¯ Production application is accessible at: http://$ALB_DNS"
            
          else
            echo "âŒ Load Balancer DNS not found in stack outputs"
            exit 1
          fi

          # Check ECS service health
          echo "ğŸ³ Checking ECS service health..."
          ECS_SERVICE_STATUS=$(aws ecs describe-services \
            --cluster CourtCaseCluster \
            --services BackendService \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].status' \
            --output text 2>/dev/null || echo "NOT_FOUND")

          if [ "$ECS_SERVICE_STATUS" = "ACTIVE" ]; then
            echo "âœ… ECS service is active and healthy"
          else
            echo "âš ï¸  ECS service status: $ECS_SERVICE_STATUS"
          fi

          echo "âœ… Comprehensive post-deployment validation completed"
        timeout-minutes: 15

      - name: Create deployment summary
        if: always()
        run: |
          echo "## ğŸš€ Production Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ job.status }}" = "success" ]; then
            echo "### âœ… Deployment Status: SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ğŸ‰ **Production deployment completed successfully!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Deployment Details:**" >> $GITHUB_STEP_SUMMARY
            echo "- ğŸ“ Environment: Production" >> $GITHUB_STEP_SUMMARY
            echo "- ğŸ·ï¸  Backend Image: \`${{ secrets.DOCKER_USERNAME }}/court-case-backend:latest\`" >> $GITHUB_STEP_SUMMARY
            echo "- ğŸ·ï¸  Media Image: \`${{ secrets.DOCKER_USERNAME }}/court-case-media:latest\`" >> $GITHUB_STEP_SUMMARY
            echo "- ğŸŒ Region: ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY
            echo "- â° Deployment Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
            echo "1. Monitor application health in AWS Console" >> $GITHUB_STEP_SUMMARY
            echo "2. Check CloudWatch logs for any issues" >> $GITHUB_STEP_SUMMARY
            echo "3. Verify all application features are working correctly" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ Deployment Status: FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Production deployment failed!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Troubleshooting Steps:**" >> $GITHUB_STEP_SUMMARY
            echo "1. Check the workflow logs for detailed error information" >> $GITHUB_STEP_SUMMARY
            echo "2. Verify AWS credentials and permissions" >> $GITHUB_STEP_SUMMARY
            echo "3. Check for resource conflicts or dependency issues" >> $GITHUB_STEP_SUMMARY
            echo "4. Consider running with \`force_cleanup=true\` if there are resource conflicts" >> $GITHUB_STEP_SUMMARY
            echo "5. Review CloudFormation events in AWS Console" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Notify deployment result
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "ğŸ‰ Production deployment successful!"
            echo "ğŸŒ Application is now live and accessible"
            echo "ğŸ“Š Monitor the application health and performance"
          else
            echo "âŒ Production deployment failed!"
            echo "ğŸ” Check the logs and troubleshooting steps above"
            echo "ğŸš¨ Production environment may be in an inconsistent state"
            echo "ğŸ’¡ Consider immediate rollback if necessary"
          fi
